import ts from "typescript";
import _ from "lodash"

const convertToObject = (typeLiteral: string, showDiagnostics?: true): string | object => {
  const src = ts.createSourceFile("", typeLiteral, ts.ScriptTarget.Latest)
  const op: ts.CompilerOptions = {
    module: ts.ModuleKind.ES2022,
    target: ts.ScriptTarget.Latest,
  }
  // Rudimentary diagnostics - just shows some syntax errors
  const errs = ts.transpileModule(src.text, { compilerOptions: op, reportDiagnostics: true }).diagnostics
  if (errs && errs.length > 0) {
    if (showDiagnostics) {
      errs.forEach((d, i) => {
        console.log(typeLiteral)
        const indentation = errs[i].start ?? 0
        console.error(new Array(indentation+1).join(" ")+"^ Error:", d.messageText)
      })
    }
    return {}
  } 

  // Does not support all types, e.g. intersections are not supported, nor are generics.
  let ids: string[] = []
  const visit = (node: ts.Node) => {
    let obj: any = {}
    let id: string = ""
    ts.forEachChild(node, (n) => {
      id = ids[ids.length-1]
      const next = visit(n)
      switch (n.kind) {
        case ts.SyntaxKind.TypeAliasDeclaration:
        case ts.SyntaxKind.UnionType:
          obj = next
          break
        case ts.SyntaxKind.Identifier:
          ids.push(n.getText(src))
          break
        case ts.SyntaxKind.TypeLiteral:
          if (Array.isArray(obj[id])) {
            obj[id].push(next) 
          } else {
            obj[id] = next
          }
          break
        case ts.SyntaxKind.PropertySignature:
          if (Object.keys(obj).length > 0) {
            Object.assign(obj, next)
          } else {
            obj = next
          }
          ids.pop()
          break
        case ts.SyntaxKind.NamedTupleMember:
          if (Array.isArray(obj)) {
            obj.push(next) 
          } else {
            obj = [next]
          }
          break
        case ts.SyntaxKind.TupleType:
          obj[id] = next
          break
        case ts.SyntaxKind.StringKeyword:
        case ts.SyntaxKind.NumberKeyword:
        case ts.SyntaxKind.BooleanKeyword:
        case ts.SyntaxKind.NullKeyword:
        case ts.SyntaxKind.VoidKeyword:
        case ts.SyntaxKind.AnyKeyword:
        case ts.SyntaxKind.SymbolKeyword:
        case ts.SyntaxKind.UnknownKeyword:
        case ts.SyntaxKind.ArrayType:
        case ts.SyntaxKind.ObjectKeyword:
        case ts.SyntaxKind.BigIntKeyword:
        case ts.SyntaxKind.LiteralType:
          const literal = n.getText(src)
          if (Object.keys(obj).length > 0) {
            if (Array.isArray(obj[id])) {
              obj[id].push(literal) 
            } else {
              obj = { [id]: [obj[id], literal]}
            }
          } else {
            obj[id] = literal
          }
          break
      }
    })
    return obj
  }

  return visit(src)
}

type Test = {
  name: string
  input: string
  expected: Object
}

const test = () => {
  console.log("Running tests...\n")
  const scenarios: Test[] = [
    {
      name: "Primitive",
      input: `type Dog = string`,
      expected: {Dog:'string'}
    },
    {
      name: "Union",
      input: `type YesNo = "Yes" | "No"`,
      expected: {YesNo:['"Yes"','"No"']}
    },
    {
      name: "Tuple",
      input: `type Purchase = [ amount: number, timestamp: string ]`,
      expected: {Purchase:[{amount:"number"},{timestamp:"string"}]}
    },
    {
      name: "Object Literal",
      input: `type Cat = { cry: "Meow", eats: "Fish" | "Cat food" }`,
      expected: {Cat:{cry:'"Meow"',eats: ['"Fish"', '"Cat food"']}}
    },
    {
      name: "Nested Object Literal",
      input: `type Test = { a: { b: { c: "hi" }, d: "there" } }`,
      expected: {Test:{a:{b:{c:'"hi"'},d:'"there"'}}}
    },
    {
      name: "Example provided in email",
      input: `type Button = { variant: "solid" | "text" };`,
      expected: {Button:{variant:['"solid"','"text"']}}
    },
    {
      name: "Invalid", // View the error generated by setting showDiagnostics to true for convertToObject()
      input: `type A = { a: a 1, b: { c: 2, d: 3 } }`,
      expected: {}
    }
  ]

  for (const sc of scenarios) {
    const res = convertToObject(sc.input)
    if (!_.isEqual(res, sc.expected)) {
      console.log("Test failed:", sc.name)
      console.log("Have:", res)
      console.log("Want:", sc.expected)
      console.log()
    } else {
      console.log("Type:", sc.name)
      console.log("Input:", sc.input)
      console.log("Output:", res)
      console.log()
    }
  }
}

test()
